(function () {
    var Point2D = function ($x = 0, $y = 0) {
        this.x = $x;
        this.y = $y;
    }

    var Segment = function ($start, $end, $name) {
        this.start = new Point2D($start.x, $start.y);
        this.end = new Point2D($end.x, $end.y);
        this.color = null
        this.name = ($name == undefined) ? "Segment" + _Math.generateRandomInt(0, 999) : $name

        this.setColor = function ($hex) {
            this.color = $hex;
        }

        this.draw = function ($context) {
            if (this.color == null) {
                console.log("line segment color is not defined.... call the setColor function(hexval)")
                this.colo = "0XFFFFFF";
            }
            $context.beginPath();
            $context.strokeStyle = this.color;
            $context.moveTo(Math.floor(this.start.x), Math.floor(this.start.y));
            $context.lineTo(Math.floor(this.end.x), Math.floor(this.end.y));
            $context.stroke();
            $context.closePath();
        }


        this.alterStart = function ($x, $y) {
            var __modX = this.start.x + $x
            var __modY = this.start.y + $y
            this.start = new Point2D(__modX, __modY)
        }

        this.alterEnd = function ($x, $y) {
            var __modX = this.start.x + $x
            var __modY = this.start.y + $y
            this.end = new Point2D(__modX, __modY)
        }

    }



    /*
     a central angle is an angle whos' points conssist of a circle's center and 2 points along the same circle's circumference...

    if you draw a line from the center of a circle  to it's circumference at a specific angle, this line would be called a "leg" or "segment".
    this uses data for a circle, and an angle to create an X/Y point for a start and end point
    */
    var CentralAngleLeg = function ($center, $chartRadius, $angle = 0) {
        this.radius = $chartRadius;
        this.PointA = new Point2D($center.x, $center.y);
        this.PointB = _Math.parametricEquation($center, this.radius, $angle);
    }




    var Label = function ($piechartlabeler, $text, $height) {

        var __txtSplitter = $text.indexOf("\n");

        this.text = (__txtSplitter > -1) ? _Words.splitStringToMultipleLines($text, __txtSplitter) : $text;



        this.lineCount = (typeof this.text == "object") ? 2 : 1;
        this.width = function () {
            var __widthVal = 0;
            switch (typeof this.text) {
                case "object":
                    var __lineA = $piechartlabeler.getLabelWidth(this.text.line.a);
                    var __lineB = $piechartlabeler.getLabelWidth(this.text.line.b);
                    __widthVal = (__lineA > __lineB) ? __lineA : __lineB;

                    break;
                case "string":
                    __widthVal = $piechartlabeler.getLabelWidth(this.text);
                    break;
                default:
                    console.log("not a recognized width?");
            }
            
            return __widthVal;
        }
        this.height = $height;
        this.color = null;
        this.draw = function ($context, $position, $col) {
            var __labelX = NaN;
            var __labelY = NaN;

            switch ($col) {
                case "left":
                    __labelX = $position.x;
                    __labelY = $position.y - this.height / 2
                    break;
                case "right":
                    __labelX = $position.x - this.width();
                    __labelY = $position.y - this.height / 2;
                    break;
                default:
                    "";
            }
            var __position = new Point2D(__labelX, __labelY);
            var __fFam = "Verdana"
            var __fSize = this.height;
            $context.beginPath();
            $context.font = __fSize + ' ' + __fFam;
            $context.fillStyle = (this.color == null) ? "0XFFFFFF" : this.color;

            switch (typeof this.text) {
                case "object":
                    var __firstLineY = Math.floor(__position.y) - this.height;
                    $context.fillText(this.text.line.a, Math.floor(__position.x), __firstLineY, this.width());
                    $context.fillText(this.text.line.b, Math.floor(__position.x), Math.floor(__position.y), this.width());

                    break;
                case "string":
                    $context.fillText(this.text, Math.floor(__position.x), Math.floor(__position.y), this.width());
                    break;
                default:


            }

            $context.closePath();
        }
        this.setColor = function ($hex) {
            this.color = $hex;
        }
        this.getLineCount = function () {
            return this.lineCount;
        }
    }

    var SliceIdentity = function ($legA, $legB, $label, $column) {
        this.legA = $legA;
        this.legB = $legB;
        this.label = $label;
        this.column = $column.toLowerCase();


        this.drawLines = function ($context) {
            this.legA.draw($context);
            this.legB.draw($context);
        }
        this.drawLabel = function ($context) {
            var __col = this.column;
            var __labelStartPos = null;
            this.label.draw($context, this.legB.end, this.column);
        }
    }

    var ChartSliceIdentifiers = function () {
        this.sliceIDs = [];
        this.addChartIdentifier = function ($sliceID) {

            this.sliceIDs.push($sliceID);
        }
        //        __sliceID.drawLabel(this.chartInstance.chart.ctx);
        this.drawLinesAndLabels = function ($context) {
            var __next = 0;
            for (var i = 0; i < this.sliceIDs.length; i++) {
                var __sliceID = this.sliceIDs[i];

                __sliceID.drawLines($context)
                __sliceID.drawLabel($context)
            }
        }
    }







    var _Words = new function () {

        this.splitStringToMultipleLines = function ($text, $breakpoint) {

            var __lineA = $text.substr(0, $text.indexOf("\n"));
            var __lineB = $text.substr($breakpoint, $text.length);
            __lineB = __lineB.substr(1)
            return {
                line: {
                    a: __lineA,
                    b: __lineB
                }
            }
        }

    }
    var _Math = new function () {

        //returns a point based on an angle, and x and y val
        /*
                            this is how to get the X and Y value of a 
                            point along the circumference of a circle
        
                            the point should be in radians, which is an angle.
                            this angle is found by drawing a leg from the circle's center, to the point, 
                            and another along the positive horizontal axis - finally - creating an angle from
                            the center of a circle caled a, "Central Angle"
                            */

        this.RGBA2Hex = function ($rgb) {
            $rgb = $rgb.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
            return ($rgb && $rgb.length === 4) ? "#" +
                ("0" + parseInt($rgb[1], 10).toString(16)).slice(-2) +
                ("0" + parseInt($rgb[2], 10).toString(16)).slice(-2) +
                ("0" + parseInt($rgb[3], 10).toString(16)).slice(-2) : '';
        }
        this.parametricEquation = function ($center, $radius, $angleAsPoint) {
            var __x = $center.x + $radius * Math.cos($angleAsPoint)
            var __y = $center.y + $radius * Math.sin($angleAsPoint)

            return new Point2D(__x, __y);
        }

        this.getSumWithCeil = function (...$numbers) {
            var __total = 0;
            for (var number in $numbers) {
                __total += number;
            }
            __total = Math.ceil(__total);
            return __total;
        }
        this.generateRandomInt = function ($rangeLow, $rangeHigh) {
            var __randomInt = NaN;
            var __low = ($rangeLow == NaN) ? Math.ceil(Math.random() * 10) : $rangeLow;
            var __high = ($rangeHigh == NaN) ? Math.ceil(Math.random() * 1000) : $rangeHigh;

            __randomInt = Math.floor(Math.random() * __high) + __low;
            return __randomInt;
        }
        this.isBetween = function ($val, $x, $y) {
            var __bool = $val >= $x && $val <= $y;
            return __bool;

        }
        this.R2D = function ($radians) {
            var __angleInDegrees = $radians * (180 / Math.PI);
            return __angleInDegrees;
        }

        this.D2R = function ($degrees) {
            var __angleInRadians = $degrees * (Math.PI / 180);
            return __angleInRadians;
        }
    }


    if (typeof Chart === 'undefined') {
        return;
    }

    function PieChartLabel() {
        this.drawDataset = this.drawDataset.bind(this);
    }



    PieChartLabel.prototype.afterDatasetsDraw = function (chartInstance) {

        if (!this.parseOptions(chartInstance)) {
            return;
        }
        this.labelBounds = [];


        chartInstance.config.data.datasets.forEach(this.drawDataset);
    };


    PieChartLabel.prototype.drawDataset = function (dataset) {
        var meta = dataset._meta[Object.keys(dataset._meta)[0]];
        var __labels = this.chartInstance.data.labels;
        var __borderColors = this.chartInstance.data.datasets[0].backgroundColor;
        var __colWidth = this.getGreatestLabelWidth(__labels);
        var __identifiers = new ChartSliceIdentifiers();
        var Data_Columns = this.getColumnPlots(__colWidth);

        var _lineData = new Array();
        //        var __lineLabelHeightMod = 0;
        var __prevInc = 0;
        var __csChord_A_PREV;
        var __csChord_B_PREV;
        var __medianDegree_previousSlice = NaN;
        var __yMod = 0;
        var __yMod_Multiplier = NaN;

        var __angleBoundsMax = 19;
        var __angleDiffs = __angleBoundsMax * 2;

        for (var i = 0; i < meta.data.length; i++) {


            var __strokeColor = _Math.RGBA2Hex(__borderColors[i]).toUpperCase();


            //in radians
            var __csChord_A = meta.data[i]._model.startAngle;
            var __csChord_B = meta.data[i]._model.endAngle;
            var __pointForSliceMIddle = (__csChord_A + __csChord_B) / 2;

            if (i != 0) {
                __prevInc = i - 1;
                __csChord_A_PREV = meta.data[__prevInc]._model.startAngle;
                __csChord_B_PREV = meta.data[__prevInc]._model.endAngle;
                __medianDegree_previousSlice = (__csChord_A_PREV + __csChord_B_PREV) / 2;

                var __diff_A = _Math.R2D(__medianDegree_previousSlice);
                var __diff_B = _Math.R2D(__pointForSliceMIddle);
                __angleDiffs = Math.abs(Math.ceil(__diff_A - __diff_B));
                switch (__quadrant) {
                    case 1:
                    case 2:
                        __yMod_Multiplier = -1
                        break
                    case 3:
                    case 4:
                        __yMod_Multiplier = 1
                        break
                    default:

                }

            } else {
                __angleDiffs = __angleBoundsMax * 2;
            }

            var __quadrant = this.getAngleQuadrant(__pointForSliceMIddle);

            var __label = new Label(this, __labels[i], this.outerLabel.fontSize);


            __label.setColor(__strokeColor);

            var __labelLineCount = __label.getLineCount();

            if (__diff_A != NaN && __diff_B != NaN && __angleDiffs <= __angleBoundsMax) {
                __yMod += 0 + (1 * __yMod_Multiplier);
            } else {
                __yMod = 0;
            }

            var __segmentA = this.getSegmentFromSliceMedian(__pointForSliceMIddle, __yMod);
            __segmentA.setColor(__strokeColor);

            var __col = undefined;

            switch (__quadrant) {
                case 1:
                case 2:
                    __col = "right"
                    var __pt = new Point2D(Data_Columns.right.bounds.right.plot.x, __segmentA.end.y);
                    var __segmentB = new Segment(__segmentA.end, __pt);
                    __segmentB.setColor(__strokeColor);
                    break;
                case 3:
                case 4:
                    __col = "left"
                    var __pt = new Point2D(Data_Columns.left.bounds.left.plot.x, __segmentA.end.y);
                    var __segmentB = new Segment(__segmentA.end, __pt);
                    __segmentB.setColor(__strokeColor);
                    break;
                default:
            }

            var __sliceID = new SliceIdentity(__segmentA, __segmentB, __label, __col)


            __identifiers.addChartIdentifier(__sliceID);
        }

        __identifiers.drawLinesAndLabels(this.chartInstance.chart.ctx);
    };

    PieChartLabel.prototype.getSegmentFromSliceMedian = function ($median, $enum) {
        var __radA = this.getChartRadius() - this.segInset;
        var __radB = this.getChartRadius() +
            this.colOffset + this.legA.length +
            ($enum * this.outerLabel.fontSize)
        //                    ($enum * this.outerLabel.labelPadding));
        var __legStart = _Math.parametricEquation(this.getChartCenter(), __radA, $median);

        var _legEnd = _Math.parametricEquation(this.getChartCenter(), __radB, $median);

        return new Segment(__legStart, _legEnd);
    }

    PieChartLabel.prototype.getAngleQuadrant = function ($angleMedian) {

        var __quadrant = 9999;
        var __median = _Math.R2D($angleMedian);
        for (var i = 0; i < this.grid.length; i++) {

            var __quad = this.grid[i].quadrant;
            var __bounds = this.grid[i].bounds;
            var __start = __bounds.start
            var __end = __bounds.end

            if (__median >= __start && __median <= __end) {
                __quadrant = __quad;
                break;
            }
        }
        return __quadrant;
    }

    PieChartLabel.prototype.getChartCenter = function () {
        var __cX = (this.chartInstance.chartArea.left + this.chartInstance.chartArea.right) / 2;
        var __cY = (this.chartInstance.chartArea.top + this.chartInstance.chartArea.bottom) / 2;
        return new Point2D(__cX, __cY);
    }

    PieChartLabel.prototype.getChartRadius = function () {
        var __chart = this.chartInstance;
        var __r = __chart.outerRadius;
        return __r;
    }

    PieChartLabel.prototype.getColumnPlots = function ($width) {
        //CentralAngleLeg(center:Point2D,radius:Radian, angle:Radian)
        var LegTo_R = new CentralAngleLeg(this.getChartCenter(), (this.getChartRadius() + this.colOffset), 0);
        var LegTo_L = new CentralAngleLeg(this.getChartCenter(), (this.getChartRadius() + this.colOffset), _Math.D2R(180))

        return {
            left: {
                bounds: {
                    left: {
                        plot: new Point2D((LegTo_L.PointB.x - $width), LegTo_L.PointB.y)
                    },
                    right: {
                        plot: new Point2D(LegTo_L.PointB.x, LegTo_L.PointB.y)
                    }
                }
            },
            right: {
                bounds: {
                    left: {
                        plot: new Point2D(LegTo_R.PointB.x, LegTo_R.PointB.y)
                    },
                    right: {
                        plot: new Point2D((LegTo_R.PointB.x + $width), LegTo_R.PointB.y)
                    }
                }
            }
        }
        //////////
        ////////
        //////
        ////
        //
    }

    PieChartLabel.prototype.getLabelWidth = function ($labelText) {


        return Math.ceil(this.chartInstance.chart.ctx.measureText($labelText).width);
    }

    PieChartLabel.prototype.getGreatestLabelWidth = function ($arr) {
        var __labelOne = $arr[0];
        var __greatestWidth = this.getLabelWidth(__labelOne);
        var __indexLabelWidth = null;
        for (var i = 0; i < $arr.length; i++) {


            var __txtSplitter = $arr[i].indexOf("\n");
            var __label = (__txtSplitter > -1) ? _Words.splitStringToMultipleLines($arr[i], __txtSplitter) : $text;

            switch (typeof __label) {
                case "object":
                    for (var line in __label) {

                        var __lineA = this.getLabelWidth(__label[line].a);
                        var __lineB = this.getLabelWidth(__label[line].b);
                        __greatestWidth
                        __indexLabelWidth = (__lineA > __lineB) ? __lineA : __lineB;

                        if (__greatestWidth < __indexLabelWidth) {
                            __greatestWidth = __indexLabelWidth;
                        }
                    }
                    break;
                case "string":

                    __indexLabelWidth = this.getLabelWidth(__labelTxt);
                    if (__greatestWidth < __indexLabelWidth) {
                        __greatestWidth = __indexLabelWidth;
                    }
                    break;

                default:
                    console.log("text is all goofed up?")
            }

        }
        return __greatestWidth;

    }

    PieChartLabel.prototype.parseOptions = function (chartInstance) {
        var PieChartLabel = chartInstance.options.pieChartLabel;
        if (PieChartLabel) {

            //constant variables to remap cardinal coordinates from worldy to digital
            const NORTH = "EAST";
            const SOUTH = "WEST";
            const EAST = "SOUTH";
            const WEST = "NORTH";

            //constants for parameter values and for setting optional parameter values
            const PADDING = "-=$padding$=-";
            const WIDTH = "-=$width$=-";
            const HEIGHT = "-=$height$=-";
            const XY = "-=$xy$=-";
            const LENGTH = "-=$length$=-";
            const OFFSET = "-=$offset$=-";

            this.ElementPoints = {
                "angle": {
                    pointA: 0,
                    pointB: 0,
                    median: 0
                },
                "line": {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 0
                },
                "label": {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 0
                }
            }




            this.grid = [
                {
                    quadrant: 1,
                    bounds: {
                        start: -90,
                        end: 0
                    }
                },
                {
                    quadrant: 2,
                    bounds: {
                        start: 0,
                        end: 90
                    }
                },
                {
                    quadrant: 3,
                    bounds: {
                        start: 90,
                        end: 180
                    }
                },
                {
                    quadrant: 4,
                    bounds: {
                        start: 180,
                        end: 270
                    }
                }
            ];

            this.chartInstance = chartInstance;
            ///variables that are not actually options FOR "PieChartLabel.JS"
            this.radius = this.chartInstance.outerRadius;
            this.canvasContext = chartInstance.chart.ctx;
            this.options = chartInstance.config.options;
            ////
            ////
            ////
            ////
            //options that can be set in the instantiation of a CHART[.js]
            //this is an option that allows a number for padding to be put around the chart's circumference where the labels will be outside of..
            this.segInset = PieChartLabel.lineInset || NaN
            this.colOffset = PieChartLabel.columnOffset || NaN
            this.legA = PieChartLabel.legA || {
                length: 30,
                thickness: 1,
                color: "black"
            }
            this.outerLabel = PieChartLabel.outerLabel || {
                labelPadding: 0,
                fontSize: 12,
                fontFamily: "Verdana",
                color: "0x000000"
            }
            this.render = PieChartLabel.render || PieChartLabel.mode;
            this.position = PieChartLabel.position || 'default';
            this.arc = PieChartLabel.arc;
            this.format = PieChartLabel.format;
            this.precision = PieChartLabel.precision || 0;
            this.fontSize = PieChartLabel.fontSize || this.options.defaultFontSize;
            this.fontColor = PieChartLabel.fontColor || this.options.defaultFontColor;
            this.fontStyle = PieChartLabel.fontStyle || this.options.defaultFontStyle;
            this.fontFamily = PieChartLabel.fontFamily || this.options.defaultFontFamily;
            this.hasTooltip = chartInstance.tooltip._active && chartInstance.tooltip._active.length;
            this.showZero = PieChartLabel.showZero;
            this.overlap = PieChartLabel.overlap;
            this.images = PieChartLabel.images || [];
            this.showActualPercentages = PieChartLabel.showActualPercentages || false;
            return true;
        } else {
            return false;
        }
    };

    Chart.pluginService.register({
        beforeInit: function (chartInstance) {
            chartInstance.PieChartLabel = new PieChartLabel();
        },

        afterDraw: function (chartInstance) {
            chartInstance.PieChartLabel.afterDatasetsDraw(chartInstance);
        }
    });


})();
