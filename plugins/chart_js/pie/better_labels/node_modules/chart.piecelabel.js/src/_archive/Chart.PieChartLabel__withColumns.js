/**

 * [Chart.PieChartLabel.js]{@link https://github.com/emn178/Chart.PieChartLabel.js}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2017
 * @license MIT
 */





/**


            /*
            ****************************************************************************
            ****************************************************************************
            :::::: Conversions and remapping coordinates, cardinal directions etc ::::::
            ****************************************************************************
            ****************************************************************************
            
            convert the 'digital' cartesian system to the
            'real world' cartesian system. Since It's rotated 90° in the computer world:
                    - East becomes North
                    - South becommes East
                    - West becommes South   &
                    - North becomes West
                    
                    - To convert the Degrees' VALUES from Digital back to Worldy:
                    
                    - 0° becomes -90°
                    - 90° becomes 0°
                    - 180° becomes 90°
                    - 270° becomes 180°
                    - 360° (clockwise from RWQ4 or DLQ3 of 0°) becomes 270°
                    
                    so a cicle goes 
                                    from:
                                            0° - 360°
                                    to:
                                            -90° - 270°
                    
                    RW == Real World
                    DL == Digital [world]
            */









(function () {
        if (typeof Chart === 'undefined') {
            //        console.warn('Can not find Chart object.');
            return;
        }

        function PieChartLabel() {
            console.log("---------< constructor >----------")
            console.log("----------------------------------")
            console.log("------------STEP1:----------------")
            console.log("----------------------------------")
            console.log("-= function PieChartLabel()")
            console.log("----------------------------------")
            this.drawDataset = this.drawDataset.bind(this);
            console.log("------< /constructor >------")

        }







        PieChartLabel.prototype.afterDatasetsDraw = function (chartInstance) {

            if (!this.parseOptions(chartInstance)) {
                return;
            }
            this.labelBounds = [];

            chartInstance.config.data.datasets.forEach(this.drawDataset);
        };

        PieChartLabel.prototype.drawDataset = function (dataset) {
            var meta = dataset._meta[Object.keys(dataset._meta)[0]];
            for (var i = 0; i < meta.data.length; i++) {}

            var __labels = this.chartInstance.data.labels
            var __columnMinWidth = getGreatestLabelWidth(__labels);

            for (var i = 0; i < meta.data.length; i++) {

                var __chartCenterX = meta.data[i]._model.x;
                var __chartCenterY = meta.data[i]._model.y;

                var __chartRadius = this.chartInstance.outerRadius;
                var __chartCircumferencePadding = 20; //add to options...

                //padding around chart (larger circle) = circ radius + __chartRadiusIncrememnt
                // draw line from chart center to new larger circle (at RW: 90° / Dig: 0°)
                // get X value of END point of line == chart column startX 
                // 








                var _line_LegB_X = this.getSumRoundedUp(__chartRadius, __chartColumnPadd);
                var _line_LegB_Y = this.getSumRoundedUp(__chartRadius, __chartColumnPadd);




                //radius of circle + where each column's side closest to center's will be
                var centerVertex_X = this.getSumRoundedUp(__chartRadius, __chartColumnPadd)

                //label data
                var __labels = this.chartInstance.data.labels[i];
                //width of each column has to be this: 
                //  -- (or will be less than the width of the largest label..)
                var __columnMinWidth = this.getGreatestLabelWidth(__labels);

                //in radians
                var __csChord_A = meta.data[i]._model.startAngle;
                var __csChord_B = meta.data[i]._model.endAngle;

                var __sliceProps = {
                    circSeg: {
                        chord: {
                            a: __csChord_A,
                            b: __csChord_B
                        }
                    }
                }

                this.setupLineCoords(__sliceProps);
            }
        };



        PieChartLabel.prototype.setupLineCoords = function ($sliceData = null) {
            /*

                    a circular segement part of a circle - upper 'boundary' is an arc and lower is a 'chord' and the chord's start and end ponts make up a central angle.

            */


            //called start angle in chart.js
            $sliceData.circSegChord_A
            //called end angle in chart.js
            $sliceData.circSegChord_B

            var cX = $center.x;
            var cY = $center.y;

            var __point_middle = ($a + $b) / 2;


            Math.cos(ElementPoints["angle"].median) * $rad;
            Math.sin(ElementPoints["angle"].median) * $rad




        }


        PieChartLabel.prototype.getSumRoundedUp = function (...$nums) {
            var __sum = NaN;

            for (var aNum in $nums) {
                var __value = aNum;
                if (isNan(aNum)) {
                    __value = 0;
                }
                __sum += __value;
            }
            __sum = Math.ceil(__sum);
            return __sum;
        }

        //parametric equation -- where $point == median from startangle and end angle?
        // this will be used to get the end point of any line that is pointing formt he center of the chart and coming out a tthe median of the angles form each slice out to each label in each column
        PieChartLabel.prototype.getXYFromPointOnCirc = function ($point, $circData) {
            var __pt = {
                x: 0,
                y: 0
            }
            __pt.x = $circData.centerX * ($circData.radius Math.cos($point))
            __pt.y = $circData.centerY * ($circData.radius + Math.sin($point))

            return __pt;
        }

        PieChartLabel.prototype.getLabelWidth = function ($labelText) {
            return Math.ceil(this.chartInstance.chart.ctx.measureText($labelText));
        }

        PieChartLabel.prototype.getGreatestLabelWidth = function ($arr) {
            var __labelOne = $arr[0];
            var __greatestWidth = this.getLabelWidth(__labelOne);

            for (var i = 0; i < $arr.length; i++) {
                var __labelTxt = $arr[i];
                var __indexLabelWidth = this.getLabelWidth(__labelOne);

                if (__greatestWidth < __indexLabelWidth) {
                    __greatestWidth = __indexLabelWidth;
                }
            }
            return __greatestWidth;

        }


        PieChartLabel.prototype.createLine = function ($angleRef, $centerPoint) {

            var canvasContext = this.canvasContext;
            var ElementPoints = this.ElementPoints;

            $centerPoint.x
            $centerPoint.y
            $angleRef.a;
            $angleRef.b;


            var __median = ($angleRef.a + $angleRef.b) / 2;
            var __centralAngleCenterPoint_X = Math.cos(ElementPoints["angle"].median) * this.chartOuterRadius;
            var __centralAngleCenterPoint_Y = Math.sin(ElementPoints["angle"].median) * this.chartOuterRadius;



            canvasContext.beginPath();





        }

        PieChartLabel.prototype.createLabel = function ($label) {
            var canvasContext = this.canvasContext;
            var ElementPoints = this.ElementPoints;

            //            canvasContext.beginPath();


            //            canvasContext.fillText();


        }


        PieChartLabel.prototype.GetNewColumn = function ($dir = undefined, $bounds = null, padding = NaN) {

            var __columnData = {
                side: $dir,
                inner: {
                    x: NaN
                },
                outer: {
                    x: NaN
                },
                width: NaN,
                padding: NaN
            }
            return __columnData;
        }





        PieChartLabel.prototype.setObjPropVal = function ($o, $p, $v) {
            if (typeof prop === "string") {
                $p = $p.split(".")
            }

            if ($p.length > 1) {
                var __shiftProp = $p.shift();
                var __objVal = ($o[e] === "[object Object]") ? $o[__shiftProp] : {};
                setSliceDataProp($o[__shiftProp] = Object.prototype.toString.call(__objVal, $p, $v)
                }
                else {
                    $o[$p[0]] = $v;
                }


            }

            PieChartLabel.prototype.initDataForSlice = function (...$props) {
                //name, bounds, padding (from chart to bounds.inner.x)
                var column = this.GetNewColumn()




            }




            PieChartLabel.prototype.setupLabels = function ($props = null) {

            }




            PieChartLabel.prototype.getAngleQuadrant = function ($angle_start = NaN, $angle_end = NaN) {
                var grid = this.grid;
                var ElementPoints = this.ElementPoints;

                var __sliceMiddle = NaN;
                __sliceMiddle = ($angle_start == NaN || $angle_end == NaN) ? ElementPoints["angle"].median : ($angle_end + $angle_start) / 2

                var QuadrantData = -1;

                var QuadrantData = new Object({
                    quadrant: NaN,
                    doesBorderTwoQuadrants: false,
                    quadrantBorder: NaN
                });

                for (var i = 0; i < grid.length; i++) {
                    var __start = grid[i].start;
                    var __end = grid[i].end;

                    /*
                    if (__sliceMiddle == 0) {    
                    */ //trying out the range/variance between: 358° - 02°

                    if (__sliceMiddle > 358 && __sliceMiddle < 2) {
                        //                console.log("Angle is exactly ZERO")
                        doesBorderTwoQuadrants.doesBorderTwoQuadrants = true;
                        doesBorderTwoQuadrants.quadrantBorder = 0;
                        break;
                    }
                    /*
                    } else if (__sliceMiddle == 90) {
                    */ //trying out the range/variance: between 88° - 9°2
                    // True Cartesian Coordinate:
                    //                                EAST
                    // Digital Cartesian Coordinate:
                    //                                SOUTH
                    else if (__sliceMiddle > 88 && __sliceMiddle < 92) {
                        //                console.log("Angle is exactly 90")
                        doesBorderTwoQuadrants.doesBorderTwoQuadrants = true;
                        doesBorderTwoQuadrants.quadrantBorder = 90;
                        break;
                    }
                    /*
                    } else if (__sliceMiddle == 180) {
                    */ //trying out the range/variance between: 178° - 182° 
                    // True Cartesian Coordinate:
                    //                                SOUTH
                    // Digital Cartesian Coordinate:
                    //                                WEST
                    else if (__sliceMiddle > 178 && __sliceMiddle < 182) {
                        //                console.log("Angle is exactly 180")
                        doesBorderTwoQuadrants.doesBorderTwoQuadrants = true;
                        doesBorderTwoQuadrants.quadrantBorder = 180;
                        break;
                    }

                    /*
                    } else if (__sliceMiddle == 360) {
                    */ //trying out the range/variance between: 358° - 02° 
                    // True Cartesian Coordinate:
                    //                                NORTH
                    // Digital Cartesian Coordinate:
                    //                                WEST
                    if (__sliceMiddle > 358 && __sliceMiddle < 2) {
                        //                console.log("Angle is exactly 360")
                        doesBorderTwoQuadrants.doesBorderTwoQuadrants = true;
                        doesBorderTwoQuadrants.quadrantBorder = 360;

                        break;
                    } else {
                        //if the label is anywhere but 0, 90, 180 or "360" / 270:
                        if (__sliceMiddle >= __start && __sliceMiddle <= __end) {
                            QuadrantData.quadrant = grid[i].quadrant;
                            break;
                        }
                    }
                }
                return QuadrantData;
            }


            PieChartLabel.prototype.convertAngleValue = function ($angle = 0, $to = "radians") {
                var __returnValue = "the parameter supplied was not an acceptable one. use degree/s or radian/s in the form of a string";
                switch ($to) {
                    case "degree":
                        __returnValue = $angle * (180 / Math.PI);
                        break;
                    case "degrees":
                        __returnValue = $angle * (180 / Math.PI);
                        break
                    case "radian":
                        __returnValue = $angle * (Math.PI / 180);
                        break;
                    case "radians":
                        __returnValue = $angle * (Math.PI / 180);
                        break;
                    default:
                        __returnValue = $angle * (180 / Math.PI);
                }
                return __returnValue;
            }







            PieChartLabel.prototype.parseOptions = function (chartInstance) {
                var PieChartLabel = chartInstance.options.pieChartLabel;
                if (PieChartLabel) {
                    //            this.canvasContext = null;
                    //            this.pieChart_ReverseMortgage = null;
                    //            this.startX = 200; //???
                    //            this.startY = 200; //????
                    //            this.chartOuterRadius = 100;
                    //            this.angle_start = 0;
                    //            this.angle_end = Math.PI * 2;
                    //            this.canvasElement = null;
                    // </end vals the chart.js chart should populate>

                    //constant variables to remap cardinal coordinates from worldy to digital
                    const NORTH = "EAST";
                    const SOUTH = "WEST";
                    const EAST = "SOUTH";
                    const WEST = "NORTH";

                    //constants for parameter values and for setting optional parameter values
                    const PADDING = "-=$padding$=-";
                    const WIDTH = "-=$width$=-";
                    const HEIGHT = "-=$height$=-";
                    const XY = "-=$xy$=-";
                    const LENGTH = "-=$length$=-";
                    const OFFSET = "-=$offset$=-";
                    this.SliceData = new Object();
                    this.SliceData.Labels = new Array();
                    //                    this.SliceData.IndicatorLines =

                    this.ElementPoints = {
                        "angle": {
                            pointA: 0,
                            pointB: 0,
                            median: 0
                        },
                        "line": {
                            x1: 0,
                            y1: 0,
                            x2: 0,
                            y2: 0
                        },
                        "label": {
                            x1: 0,
                            y1: 0,
                            x2: 0,
                            y2: 0
                        }
                    }


                    this.CartesianDegreesRemap = {
                        0: -90,
                        90: 0,
                        180: 180,
                        360: 270
                    }

                    this.grid = [
                        {
                            quadrant: 1,
                            NORTH: 0,
                            EAST: 90
                },
                        {
                            quadrant: 2,
                            EAST: 90,
                            SOUTH: 180
                },
                        {
                            quadrant: 3,
                            SOUTH: 180,
                            WEST: 270
                },
                        {
                            quadrant: 4,
                            WEST: 270,
                            NORTH: 360
                }
            ];

                    this.chartInstance = chartInstance;
                    ///variables that are not actually options FOR "PieChartLabel.JS"
                    this.chartOuterRadius = this.chartInstance.outerRadius;
                    this.canvasContext = chartInstance.chart.ctx;
                    this.options = chartInstance.config.options;
                    ////
                    ////
                    ////
                    ////
                    //options that can be set in the instantiation of a CHART[.js]
                    //this is an option that allows a number for padding to be put around the chart's circumference where the labels will be outside of..
                    this.circPad = PieChartLabel.labelColumnX;
                    this.render = PieChartLabel.render || PieChartLabel.mode;
                    this.position = PieChartLabel.position || 'default';
                    this.arc = PieChartLabel.arc;
                    this.format = PieChartLabel.format;
                    this.precision = PieChartLabel.precision || 0;
                    this.fontSize = PieChartLabel.fontSize || this.options.defaultFontSize;
                    this.fontColor = PieChartLabel.fontColor || this.options.defaultFontColor;
                    this.fontStyle = PieChartLabel.fontStyle || this.options.defaultFontStyle;
                    this.fontFamily = PieChartLabel.fontFamily || this.options.defaultFontFamily;
                    this.hasTooltip = chartInstance.tooltip._active && chartInstance.tooltip._active.length;
                    this.showZero = PieChartLabel.showZero;
                    this.overlap = PieChartLabel.overlap;
                    this.images = PieChartLabel.images || [];
                    this.showActualPercentages = PieChartLabel.showActualPercentages || false;
                    return true;
                } else {
                    return false;
                }
            };

            .pluginService.register({
                beforeInit: function (chartInstance) {
                    chartInstance.PieChartLabel = new PieChartLabel();
                },

                afterDraw: function (chartInstance) {
                    chartInstance.PieChartLabel.afterDatasetsDraw(chartInstance);
                }
            });

        })();
